
i would like to initiate a new session with you.  summarize and prepare new session for a prompt to correctly handle all rules set forth in this session except using ts files.  make it the best prompt you possibly can for finishing this website. adjust existing prompt and rules to suit your preference. 
I'm developing the Top Chef Fantasy app using Firebase for both authentication and database. So far, I've migrated server components (auth middleware, league controller, server initialization, challenge controller, message functionality) and client components (chef management, user profile management) to Firebase/Firestore.

The next phase is enhancing the authentication system. I already have an authService.js implementing core Firebase auth, but it needs password reset and email verification capabilities.

Please always:
1. Review the entire codebase and check dependencies for compatibility
2. Adhere strictly to the ruleset guidelines including comprehensive feature audits
3. Provide complete file replacements, never partial changes
4. Follow established Firebase patterns with API fallbacks
5. Ensure React 19 compatibility (useContext hooks, component state, cleanup)
6. Include git commit messages for each updated file
Request precise error context: Include exact error message, line number, and relevant component chain
Specify React 19 compatibility: Explicitly mention that solutions must use React 19 features
Request error handling: Ask for full error handling with proper logging
Require event cleanup: Specifically ask for proper event listeners cleanup
Demand dependency array completeness: All hooks should have optimal dependency arrays
Enforce useCallback/useMemo: Request memoization for all functions/computed values
Request reduced dependencies: Solutions should minimize external dependencies
Force JSDoc compliance: Request proper parameter typing and return values
Demand code format: Request code that follows specific formatting rules
Require test considerations: Ask how the solution would be tested


Focus on one functionality area at a time. After authentication, we'll tackle league management, challenge integration, and roster functionality.

The goal is a fully functional Firebase-based application with proper error handling, comprehensive features, and fallback mechanisms.

Review my existing Firebase implementation files first, then only suggest missing components needed to complete the transition. Don't repeat steps I've already completed.


React 19 Features:
Use direct ref props instead of forwardRef when possible for function components.
Add cleanup functions for ref callbacks that return a function.
Use <Context.Provider> syntax correctly in React 19 for context providers.
Implement useActionState for form handling instead of manual isPending state.
Use useOptimistic for immediate UI feedback during async operations, especially for chat messages.
Implement form action props for automatic form submission and reset.
Use document metadata tags (<title>, <meta>, <link>) directly in components like Dashboard.jsx.
Implement resource preloading APIs (prefetchDNS, preconnect, preload, preinit) for performance, particularly for league data.
TypeScript & JSX Compatibility:
Use .tsx extension for files containing JSX and TypeScript syntax to ensure type safety.
Define TypeScript interfaces or types for component props and complex objects to ensure type safety, avoiding lazy workarounds.
When fixing TypeScript errors, prioritize solutions that satisfy the type system.
Use direct equality checks for narrowing string literals in HTML attributes, e.g., in Button.jsx.
For buttons, directly compare type to 'button' | 'submit' | 'reset' instead of using includes().
Ensure consistent parameter naming in JSDoc and implementation for clarity, especially in services like authService.ts.
Props & Components Structure:
Ensure all destructured props have default values to prevent undefined errors, e.g., in Input.jsx.
Replace React.FC with proper function declarations for better TypeScript compatibility.
For component libraries (e.g., Button, Input, Card), define named functions first, then wrap in forwardRef if needed.
Use React.forwardRef with named function components for better TypeScript support.
Explicitly import React when using React.forwardRef, even with JSX transform.
When using forwardRef, receive 'props' as a single parameter and destructure inside the function.
Always destructure props inside the function body for forwardRef components, not in parameters.
Use shorthand fragments (<>) when no key is needed, e.g., in ChatPanel.tsx.
Organize component files with hooks at the top, helper functions next, then JSX return, e.g., Header.tsx.
Use logical && operator for conditional rendering only with boolean left operand, e.g., in LoadingScreen.tsx.
Context & Providers:
Always provide initial default values when using createContext() with proper types, e.g., in AuthContext.tsx.
Ensure default context values match the provider's value types, using generics if necessary, e.g., in LeagueContext.tsx.
Make context providers use memoized values to prevent unnecessary re-renders, e.g., in ChatContext.tsx.
React Hooks:
Ensure all useState hooks have proper typed initialization, e.g., [], {}, '', 0 in useChat.tsx.
Add cleanup functions to useEffect hooks that subscribe to events or timers, e.g., Firestore subscriptions in useLeague.tsx.
Follow exhaustive deps rule for dependency arrays, ensuring completeness, e.g., in useSocket.tsx.
Keep hook order consistent at the top of components for predictability, e.g., useAuth.tsx.
Prefer useEffect over useLayoutEffect for browser performance, e.g., in useTheme.tsx.
Use React.useMemo for expensive calculations only, as React 19 has automatic memo, e.g., in ChefRoster.tsx.
Use React 19’s useOptimistic for optimistic UI updates, especially for chat messages in ChatMessage.tsx.
Use React.useId() for accessibility, e.g., in Input.tsx.
Define event handlers outside of useEffect and memoize with useCallback to prevent unnecessary re-renders, e.g., in Button.tsx.
HTML Elements & Attributes:
Use strict HTML attribute types (e.g., button must use type='button'|'submit'|'reset'), e.g., in ThemeToggle.tsx.
Add proper button types and event handler defaults to all interactive elements, e.g., Sidebar.tsx.
Use preventDefault() in event handlers when appropriate, e.g., in form submissions in Login.tsx.
Add aria-labels to interactive elements for accessibility, e.g., MobileNav.tsx.
Set explicit width/height on images to prevent layout shifts, e.g., in Logo.tsx.
Styling & UI:
Verify CSS class conditionals have fallbacks, e.g., className={condition ? 'active' : ''} in ThemeToggle.tsx.
Use Tailwind classes consistently over inline styles, per tailwind.config.js, e.g., in Card.tsx.
Implement proper dark mode contrasts for all UI components, managed via ThemeContext.tsx.
Add animation transitions between route changes, e.g., in MainLayout.tsx with React Router.
Data & API:
Use optional chaining for nested object properties, e.g., user?.profile?.name in authService.ts.
Ensure API service functions have try/catch error handling, e.g., in leagueService.ts.
Add loading states for data-fetching operations, e.g., in Dashboard.tsx.
Validate forms client-side before API calls, e.g., in Register.tsx.
Maintain consistent error message patterns across forms and API responses, e.g., in api.ts.
Prefer the nullish coalescing operator (??) over logical OR (||) for default values with undefined, e.g., in chefService.ts.
Destructure API responses with defaults, e.g., const { data = [] } = await api.get(...) in messageService.ts.
Use date-fns consistently for date formatting instead of raw Date objects, e.g., in Schedule.tsx.
Routing:
Use template literals correctly for route paths, e.g., ${path} in App.tsx.
Ensure compatibility with React Router v7, e.g., using new hooks in ProtectedRoute.tsx.
Performance & Best Practices:
Ensure components work with Strict Mode double-rendering, e.g., test in main.tsx.
Use <Suspense> and error boundaries for proper loading/error states, e.g., in MainLayout.tsx.
Add error boundaries around data-fetching components, e.g., LeagueDetail.tsx.
Add data-testid attributes for testing, e.g., in Button.tsx and Input.tsx.
Avoid direct DOM manipulation; use refs properly, e.g., in ChatPanel.tsx.
Properly clean up socket connections and subscriptions, e.g., Firestore listeners in useSocket.tsx.
Rendering:
Ensure unique key props in map() functions, e.g., in ChefRoster.tsx.
Handle empty states in list components, e.g., in Leagues.tsx.
Additional Enhancements
For your project, consider these additions:

Firebase-Specific Practices: Ensure Firestore subscriptions are cleaned up in useEffect (already covered). Add: "Optimize Firestore queries with indexes for better performance, especially for chat and league data."
Chat Performance: "Use virtualized lists (e.g., react-window) for long chat histories in ChatPanel.tsx to improve rendering performance."
Authentication: "Use Firebase’s onAuthStateChanged in AuthContext.tsx to synchronize authentication state with React state."
