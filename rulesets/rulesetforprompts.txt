Authentication System Conflict: You have both JWT auth (server) and Firebase auth (client) implementations
*completed/React 19 Context API Syntax: Your context providers use outdated syntax
Database Inconsistency: MongoDB models in server but Firebase Firestore references in client
Dependencies Compatibility: Several packages may need updates for React 19
Socket.io Connection: Possible disconnection between client and server implementations

"Review my existing Firebase implementation files first, then only suggest missing components needed to complete the transition. Don't repeat steps I've already completed."


React 19 Features:
Use direct ref props instead of forwardRef when possible for function components.
Add cleanup functions for ref callbacks that return a function.
Use <Context.Provider> syntax correctly in React 19 for context providers.
Implement useActionState for form handling instead of manual isPending state.
Use useOptimistic for immediate UI feedback during async operations, especially for chat messages.
Implement form action props for automatic form submission and reset.
Use document metadata tags (<title>, <meta>, <link>) directly in components like Dashboard.jsx.
Implement resource preloading APIs (prefetchDNS, preconnect, preload, preinit) for performance, particularly for league data.
TypeScript & JSX Compatibility:
Use .tsx extension for files containing JSX and TypeScript syntax to ensure type safety.
Define TypeScript interfaces or types for component props and complex objects to ensure type safety, avoiding lazy workarounds.
When fixing TypeScript errors, prioritize solutions that satisfy the type system.
Use direct equality checks for narrowing string literals in HTML attributes, e.g., in Button.jsx.
For buttons, directly compare type to 'button' | 'submit' | 'reset' instead of using includes().
Ensure consistent parameter naming in JSDoc and implementation for clarity, especially in services like authService.ts.
Props & Components Structure:
Ensure all destructured props have default values to prevent undefined errors, e.g., in Input.jsx.
Replace React.FC with proper function declarations for better TypeScript compatibility.
For component libraries (e.g., Button, Input, Card), define named functions first, then wrap in forwardRef if needed.
Use React.forwardRef with named function components for better TypeScript support.
Explicitly import React when using React.forwardRef, even with JSX transform.
When using forwardRef, receive 'props' as a single parameter and destructure inside the function.
Always destructure props inside the function body for forwardRef components, not in parameters.
Use shorthand fragments (<>) when no key is needed, e.g., in ChatPanel.tsx.
Organize component files with hooks at the top, helper functions next, then JSX return, e.g., Header.tsx.
Use logical && operator for conditional rendering only with boolean left operand, e.g., in LoadingScreen.tsx.
Context & Providers:
Always provide initial default values when using createContext() with proper types, e.g., in AuthContext.tsx.
Ensure default context values match the provider's value types, using generics if necessary, e.g., in LeagueContext.tsx.
Make context providers use memoized values to prevent unnecessary re-renders, e.g., in ChatContext.tsx.
React Hooks:
Ensure all useState hooks have proper typed initialization, e.g., [], {}, '', 0 in useChat.tsx.
Add cleanup functions to useEffect hooks that subscribe to events or timers, e.g., Firestore subscriptions in useLeague.tsx.
Follow exhaustive deps rule for dependency arrays, ensuring completeness, e.g., in useSocket.tsx.
Keep hook order consistent at the top of components for predictability, e.g., useAuth.tsx.
Prefer useEffect over useLayoutEffect for browser performance, e.g., in useTheme.tsx.
Use React.useMemo for expensive calculations only, as React 19 has automatic memo, e.g., in ChefRoster.tsx.
Use React 19’s useOptimistic for optimistic UI updates, especially for chat messages in ChatMessage.tsx.
Use React.useId() for accessibility, e.g., in Input.tsx.
Define event handlers outside of useEffect and memoize with useCallback to prevent unnecessary re-renders, e.g., in Button.tsx.
HTML Elements & Attributes:
Use strict HTML attribute types (e.g., button must use type='button'|'submit'|'reset'), e.g., in ThemeToggle.tsx.
Add proper button types and event handler defaults to all interactive elements, e.g., Sidebar.tsx.
Use preventDefault() in event handlers when appropriate, e.g., in form submissions in Login.tsx.
Add aria-labels to interactive elements for accessibility, e.g., MobileNav.tsx.
Set explicit width/height on images to prevent layout shifts, e.g., in Logo.tsx.
Styling & UI:
Verify CSS class conditionals have fallbacks, e.g., className={condition ? 'active' : ''} in ThemeToggle.tsx.
Use Tailwind classes consistently over inline styles, per tailwind.config.js, e.g., in Card.tsx.
Implement proper dark mode contrasts for all UI components, managed via ThemeContext.tsx.
Add animation transitions between route changes, e.g., in MainLayout.tsx with React Router.
Data & API:
Use optional chaining for nested object properties, e.g., user?.profile?.name in authService.ts.
Ensure API service functions have try/catch error handling, e.g., in leagueService.ts.
Add loading states for data-fetching operations, e.g., in Dashboard.tsx.
Validate forms client-side before API calls, e.g., in Register.tsx.
Maintain consistent error message patterns across forms and API responses, e.g., in api.ts.
Prefer the nullish coalescing operator (??) over logical OR (||) for default values with undefined, e.g., in chefService.ts.
Destructure API responses with defaults, e.g., const { data = [] } = await api.get(...) in messageService.ts.
Use date-fns consistently for date formatting instead of raw Date objects, e.g., in Schedule.tsx.
Routing:
Use template literals correctly for route paths, e.g., ${path} in App.tsx.
Ensure compatibility with React Router v7, e.g., using new hooks in ProtectedRoute.tsx.
Performance & Best Practices:
Ensure components work with Strict Mode double-rendering, e.g., test in main.tsx.
Use <Suspense> and error boundaries for proper loading/error states, e.g., in MainLayout.tsx.
Add error boundaries around data-fetching components, e.g., LeagueDetail.tsx.
Add data-testid attributes for testing, e.g., in Button.tsx and Input.tsx.
Avoid direct DOM manipulation; use refs properly, e.g., in ChatPanel.tsx.
Properly clean up socket connections and subscriptions, e.g., Firestore listeners in useSocket.tsx.
Rendering:
Ensure unique key props in map() functions, e.g., in ChefRoster.tsx.
Handle empty states in list components, e.g., in Leagues.tsx.
Additional Enhancements
For your project, consider these additions:

Firebase-Specific Practices: Ensure Firestore subscriptions are cleaned up in useEffect (already covered). Add: "Optimize Firestore queries with indexes for better performance, especially for chat and league data."
Chat Performance: "Use virtualized lists (e.g., react-window) for long chat histories in ChatPanel.tsx to improve rendering performance."
Authentication: "Use Firebase’s onAuthStateChanged in AuthContext.tsx to synchronize authentication state with React state."